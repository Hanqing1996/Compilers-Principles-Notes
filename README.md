# Compilers-Principles-Notes
编译原理相关


程序语言都是怎么发明的？ - doodlewind的回答 - 知乎
https://www.zhihu.com/question/358636057/answer/917465056

#### 编译器的工作
把 if else 之类的源码字符串，转换成 JMP 之类的汇编码字符串或字节码数组。是一个**输入字符串，输出字符串或数组**的过程
#### 自举
用这门语言实现了这门语言的编译器（但是不要求编译结果的语言是什么，可以比自己高级，也可以比自己低级），这门语言就称为“可以自举”。

* TypeScript 是自举的
TS 编译器是一个【用 TS 自己写的，能把 TS 编译成 JS】的软件

* C语言是自举的
1. 首先，简化C语言的设计，只选择最最基本、不得不实现的功能，形成一个C语言的子集。我们可以叫它C0。
2. 用汇编语言实现C0语言的编译器，由于C0功能很少，比较容易直接写一个编译器。
3. 用C0语言去实现更多必要的功能，由于C0语言功能太弱，遇到不好写的地方可以用汇编来打补丁。最终你得到了一个改进版的C0语言，我们称之为C1。
4. 用C1语言去继续实现更多C语言功能，不好写的地方继续用汇编打补丁。可以得到C2语言
5. 以此类推……
6. 到Cn语言的时候，你已经得到了一个足够接近C语言的编译器。最终，你得到了一份C语言的编译器。之前的从C0版到Cn-1 版的编译器，都可以扔掉了。

为什么要分N个步骤呢？主要还是为了解释C语言慢慢进化的历史过程。实际上不见得要分很多步，很多中间步骤只是代表了远古大神们迭代改进的过程。如果大神足够神，可以更简化。直接用汇编语言写一个C语言编译器，然后再用C语言写一个C语言编译器的源码，用汇编版的编译器 编译这个C代码，即可得到一个编译器。之后那个汇编语言的版本就可以扔掉了。


> 一般来说，某种新语言 X 的第一个编译器 C1，需要用另一种语言来编写。接下来你就可以用 C1 编译出一个部分用 X 来写的新编译器 C2，而 C2 又可以编译出一个支持更多 X 特性的 C3，然后 C3 编译出 X 支持更好的 C4……该过程重复多次后语言 x 即可自举。

> 历史上，最早的 C 编译器就是汇编实现的。而最早的 C++ 编译器，则是用 C with Class 这种介于 C 和 C++ 之间的语言来实现的。当时已经有了能编译 C with Class 的编译器，用这种编译器编译出来的第一个 C++ 编译器还比较简陋，只是把 C++ 转成 C，然后再用 C 编译器去编译（得到部分可用 C++ 写的编译器）。但有了这个起点后，人们就能用 C++ 来开发越来越强的 C++ 编译器了。所谓道生一，一生二，二生三，三生万物，大抵如此。

直到今天，我们还能看到自举的影子。例如 gcc 编译器就把自举当作了对自身的测试用例。你可以用大版本为 N-1 的旧版 gcc 构建出大版本为 N 的新版 gcc，但这个过程一共会编译三遍：用旧版 gcc 编译出新版 gcc用新版 gcc 编译自己重复一次步骤 2，对比结果是否完全一致

理论依据：NewCompiler1 和 NewCompiler2 都是用相同的 NewCompiler 源码编译出的程序。它们都给定了 NewCompiler 这份源码作为相同的输入，因此不管它们自己是用什么编译器编译的（如 NewCompiler1 用的 OldCompiler 和 NewCompiler2 用的 NewCompiler1），它们所生成的输出都应该一致。所以步骤 2 和 3 所输出的 NewCompiler2 和 NewCompiler3 就也应该一致。
